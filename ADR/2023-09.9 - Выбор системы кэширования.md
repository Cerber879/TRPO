**Дата:** 20 сентября 2023 г.

**Статус:** Принято

**Контекст:**

Система поиска и рекомендаций ресторанов должна обеспечивать высокую производительность при большом количестве пользователей. Необходимо кэшировать часто запрашиваемые данные (списки ресторанов, результаты поиска, рекомендации, рейтинги) для снижения нагрузки на базу данных и улучшения времени отклика.

**Рассмотренные варианты:**

1. **Redis:** In-memory хранилище данных с поддержкой различных структур данных. Высокая производительность, поддержка TTL.
2. **In-memory кэш приложения:** Кэширование в памяти самого приложения (например, Caffeine для Kotlin). Простое решение, не требует дополнительной инфраструктуры.
3. **Memcached:** Простое in-memory хранилище ключ-значение. Легче в настройке, но менее функционально чем Redis.
4. **Без кэширования:** Отказ от кэширования на начальном этапе для упрощения архитектуры.

**Решение:**

Выбран простой подход: in-memory кэш приложения (Caffeine) для базового кэширования с возможностью добавления Redis в будущем при необходимости.

**Обоснование:**

- **Простота:** In-memory кэш не требует настройки дополнительной инфраструктуры, что упрощает разработку и развертывание.
- **Достаточность:** Для учебного проекта и начального этапа in-memory кэш покрывает основные потребности в кэшировании.
- **Производительность:** Caffeine обеспечивает высокую производительность для кэширования в рамках одного приложения.
- **Гибкость:** При необходимости масштабирования можно легко добавить Redis без изменения основной логики приложения.
- **Минимальные требования:** Не требует дополнительных ресурсов и настройки, что важно для учебного проекта.

**Недостатки решения:**

- **Ограниченное масштабирование:** In-memory кэш не работает между несколькими инстансами приложения.
- **Потеря данных при перезапуске:** Данные кэша теряются при перезапуске приложения.

**Последствия:**

- Необходимо определить стратегию кэширования для различных типов данных (рестораны, отзывы, рекомендации, рейтинги).
- Требуется настройка инвалидации кэша при обновлении данных.
- При необходимости горизонтального масштабирования следует рассмотреть переход на Redis.
- Рекомендуется использовать TTL для автоматической очистки устаревших данных из кэша.

