**Дата:** 20 сентября 2025 г.

**Статус:** Принято

**Контекст:**

Система должна обеспечивать высокую производительность при большом количестве пользователей. Нужно кэшировать часто запрашиваемые данные (списки ресторанов, результаты поиска, рекомендации, рейтинги) для снижения нагрузки на базу данных и улучшения времени отклика.

**Рассмотренные варианты:**

1. **Redis:** In-memory хранилище данных с поддержкой различных структур данных. Высокая производительность, поддержка TTL.
2. **In-memory кэш приложения:** Кэширование в памяти самого приложения (например, Caffeine для Kotlin). Простое решение, не требует дополнительной инфраструктуры.
3. **Memcached:** Простое in-memory хранилище ключ-значение. Легче в настройке, но менее функционально чем Redis.
4. **Без кэширования:** Отказ от кэширования на начальном этапе для упрощения архитектуры.

**Решение:**

Выбран Redis для распределенного кэширования и хранения сессий.

**Обоснование:**

- **Распределенное кэширование:** Redis работает как отдельный сервис, доступный всем микросервисам, что критично для микросервисной архитектуры.
- **Масштабируемость:** Redis поддерживает кластеризацию и репликацию, что позволяет масштабировать кэш независимо от приложений.
- **Богатый функционал:** Поддержка различных структур данных (strings, hashes, lists, sets), что позволяет реализовать сложные сценарии кэширования.
- **Персистентность:** Возможность настройки персистентности данных, что важно для критичных данных (сессии, токены).
- **Производительность:** Высокая производительность для операций чтения/записи, что критично для снижения нагрузки на БД.
- **Опыт команды:** У нас уже есть опыт работы с Redis, что позволит быстро настроить и оптимизировать кэширование.

**Недостатки решения:**

- **Дополнительная инфраструктура:** Требуется настройка и поддержка отдельного сервиса Redis.
- **Сетевая задержка:** По сравнению с in-memory кэшем есть небольшая сетевая задержка, но она минимальна при правильной настройке.

**Последствия:**

- Необходимо определить стратегию кэширования для различных типов данных (рестораны, отзывы, рекомендации, рейтинги, сессии).
- Требуется настройка инвалидации кэша при обновлении данных через события RabbitMQ или прямое удаление ключей.
- Настроим Redis кластер для высокой доступности и производительности.
- Используем TTL для автоматической очистки устаревших данных из кэша.
- Реализуем паттерн Cache-Aside для большинства данных и Write-Through для критичных данных (сессии).

